[
    {
        "algorithm": "Bubble Sort",
        "time_complexity": "O(n^2)",
        "implementations": [
            {
                "language": "C",
                "code": "void bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion Sort",
        "time_complexity": "O(n^2)",
        "implementations": [
            {
                "language": "C",
                "code": "void insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Selection Sort",
        "time_complexity": "O(n^2)",
        "implementations": [
            {
                "language": "C",
                "code": "void selectionSort(int arr[], int n) {\n    int i, j, min_idx;\n    for (i = 0; i < n-1; i++) {\n        min_idx = i;\n        for (j = i+1; j < n; j++) {\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Merge Sort",
        "time_complexity": "O(n log n)",
        "implementations": [
            {
                "language": "C",
                "code": "void mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}"
            }
        ],
        "sub_functions": [
            {
                "name": "merge",
                "language": "C",
                "code": "void merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Quick Sort",
        "time_complexity": "O(n log n) average, O(n^2) worst-case",
        "implementations": [
            {
                "language": "C",
                "code": "void quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}"
            }
        ],
        "sub_functions": [
            {
                "name": "partition",
                "language": "C",
                "code": "int partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}"
            }
        ]
    },
    {
        "algorithm": "Counting Sort",
        "time_complexity": "O(n+k)",
        "implementations": [
            {
                "language": "C",
                "code": "void countingSort(char arr[]) {\n    char output[strlen(arr)];\n    int count[RANGE + 1], i;\n    memset(count, 0, sizeof(count));\n    for (i = 0; arr[i]; ++i)\n        ++count[arr[i]];\n    for (i = 1; i <= RANGE; ++i)\n        count[i] += count[i - 1];\n    for (i = 0; arr[i]; ++i) {\n        output[count[arr[i]] - 1] = arr[i];\n        --count[arr[i]];\n    }\n    for (i = 0; arr[i]; ++i)\n        arr[i] = output[i];\n}"
            }
        ]
    },
    {
        "algorithm": "Radix Sort",
        "time_complexity": "O(nk)",
        "implementations": [
            {
                "language": "C",
                "code": "void radixSort(int arr[], int n) {\n    int m = getMax(arr, n);\n    for (int exp = 1; m/exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}"
            }
        ],
        "sub_functions": [
            {
                "name": "countSort",
                "language": "C",
                "code": "void countSort(int arr[], int n, int exp) {\n    int output[n];\n    int i, count[10] = {0};\n    for (i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n    for (i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    for (i = 0; i < n; i++)\n        arr[i] = output[i];\n}"
            }
        ]
    },
    {
        "algorithm": "Heap Sort",
        "time_complexity": "O(n log n)",
        "implementations": [
            {
                "language": "C",
                "code": "void heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n    for (int i = n-1; i >= 0; i--) {\n        swap(&arr[0], &arr[i]);\n        heapify(arr, i, 0);\n    }\n}"
            }
        ],
        "sub_functions": [
            {
                "name": "heapify",
                "language": "C",
                "code": "void heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n    if (largest != i) {\n        swap(&arr[i], &arr[largest]);\n        heapify(arr, n, largest);\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion in Singly Linked List",
        "time_complexity": "O(1) for insertion at beginning/end, O(n) for insertion at nth position",
        "implementations": [
            {
                "language": "C",
                "name": " //Function to insert a new node at the beginning of the linked list",
                "code": "void insertAtBeginning(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = (*head_ref);\n    (*head_ref) = new_node;\n}"
            },
            {
                "language": "C",
                "name": "//Function to insert a new node at the end of the linked list",
                "code": "void insertAtEnd(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last = *head_ref;\n    new_node->data = new_data;\n    new_node->next = NULL;\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n    while (last->next != NULL)\n        last = last->next;\n    last->next = new_node;\n}"
            },
            {
                "language": "C",
                "name": "//Function to insert a new node at the nth position of the linked list",
                "code": "void insertAtNthPosition(struct Node** head_ref, int new_data, int position) {\n    if (position == 0)\n        insertAtBeginning(head_ref, new_data);\n    else {\n        struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n        new_node->data = new_data;\n        struct Node* temp = *head_ref;\n        for (int i = 0; i < position - 1 && temp != NULL; i++)\n            temp = temp->next;\n        if (temp == NULL)\n            return;\n        new_node->next = temp->next;\n        temp->next = new_node;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion in Singly Linked List",
        "time_complexity": "O(1) for deletion at beginning/end, O(n) for deletion at nth position",
        "implementations": [
            {
                "language": "C",
                "name": "// Function to delete a node from the beginning of the linked list\n",
                "code": "void deleteFromBeginning(struct Node** head_ref) {\n    if (head_ref == NULL)\n        return;\n    struct Node temp = *head_ref;\n    *head_ref = (*head_ref)->next;\n    free(temp);\n}"
            },
            {
                "language": "C",
                "name": "// Function to delete a node from the end of the linked list\n",
                "code": "void deleteFromEnd(struct Node** head_ref) {\n    if (head_ref == NULL)\n        return;\n    if ((*head_ref)->next == NULL) {\n        free(*head_ref);\n        *head_ref = NULL;\n        return;\n    }\n    struct Node temp = *head_ref;\n    while (temp->next->next != NULL)\n        temp = temp->next;\n    free(temp->next);\n    temp->next = NULL;\n}"
            },
            {
                "language": "C",
                "name": "// Function to delete a node from the nth position of the linked list\n",
                "code": "void deleteFromNthPosition(struct Node** head_ref, int position) {\n    if (head_ref == NULL)\n        return;\n    struct Node temp = head_ref;\n    if (position == 0) {\n        *head_ref = temp->next;\n        free(temp);\n        return;\n    }\n    for (int i = 0; temp != NULL && i < position - 1; i++)\n        temp = temp->next;\n    if (temp == NULL || temp->next == NULL)\n        return;\n    struct Node next_node = temp->next->next;\n    free(temp->next);\n    temp->next = next_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Reverse a Linked List without Changing Links (Data Reverse Only)",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to reverse a linked list without changing links between nodes (Data reverse only)\nvoid reverseData(struct Node* head) {\n    if (head == NULL || head->next == NULL)\n        return;\n    int count = 0;\n    struct Node* current = head;\n    while (current != NULL) {\n        current = current->next;\n        count++;\n    }\n    int arr[count];\n    current = head;\n    for (int i = 0; i < count; i++) {\n        arr[i] = current->data;\n        current = current->next;\n    }\n    current = head;\n    for (int i = count - 1; i >= 0; i--) {\n        current->data = arr[i];\n        current = current->next;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Linked List Insertion and Deletion",
        "time_complexity": "O(1) for insertion at beginning/end, O(n) for insertion/deletion at nth position",
        "implementations": [
            {
                "language": "C",
                "code": "// Insertion and deletion functions can be found in previous JSON examples"
            }
        ]
    },
    {
        "algorithm": "Reverse a Linked List by Changing Links Between Nodes",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to reverse a linked list by changing links between nodes\nstruct Node* reverseLinks(struct Node* head) {\n    struct Node *prev = NULL, *current = head, *next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    head = prev;\n    return head;\n}"
            }
        ]
    },
    {
        "algorithm": "Print Reverse of a Linked List without Actually Reversing",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to print reverse of a linked list without actually reversing\nvoid printReverse(struct Node* head) {\n    if (head == NULL)\n        return;\n    printReverse(head->next);\n    printf(\"%d \", head->data);\n}"
            }
        ]
    },
    {
        "algorithm": "Search an Element in a Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to search for an element in a linked list\nbool searchElement(struct Node* head, int key) {\n    struct Node* current = head;\n    while (current != NULL) {\n        if (current->data == key)\n            return true;\n        current = current->next;\n    }\n    return false;\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion in a Sorted Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node in a sorted linked list\nvoid insertInSorted(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    struct Node* current = *head_ref;\n    if (*head_ref == NULL || (*head_ref)->data >= new_data) {\n        new_node->next = *head_ref;\n        *head_ref = new_node;\n        return;\n    }\n    while (current->next != NULL && current->next->data < new_data)\n        current = current->next;\n    new_node->next = current->next;\n    current->next = new_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Delete Alternate Nodes of a Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete alternate nodes of a linked list\nvoid deleteAlternateNodes(struct Node* head) {\n    if (head == NULL || head->next == NULL)\n        return;\n    struct Node* current = head;\n    struct Node* next_next;\n    while (current != NULL && current->next != NULL) {\n        next_next = current->next->next;\n        free(current->next);\n        current->next = next_next;\n        current = next_next;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Find Middle of the Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to find the middle of a linked list\nstruct Node* findMiddle(struct Node* head) {\n    if (head == NULL)\n        return NULL;\n    struct Node* slow_ptr = head;\n    struct Node* fast_ptr = head;\n    while (fast_ptr != NULL && fast_ptr->next != NULL) {\n        slow_ptr = slow_ptr->next;\n        fast_ptr = fast_ptr->next->next;\n    }\n    return slow_ptr;\n}"
            }
        ]
    },
    {
        "algorithm": "Reverse a Linked List in Groups of Given Size",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to reverse a linked list in groups of given size\nstruct Node* reverseInGroups(struct Node* head, int k) {\n    struct Node* current = head;\n    struct Node* next = NULL;\n    struct Node* prev = NULL;\n    int count = 0;\n    while (current != NULL && count < k) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n        count++;\n    }\n    if (next != NULL)\n        head->next = reverseInGroups(next, k);\n    return prev;\n}"
            }
        ]
    },
    {
        "algorithm": "Find kth Node from End of the Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to find the kth node from the end of the linked list\nstruct Node* findKthFromEnd(struct Node* head, int k) {\n    if (head == NULL)\n        return NULL;\n    struct Node* fast = head;\n    struct Node* slow = head;\n    for (int i = 0; i < k; i++) {\n        if (fast == NULL)\n            return NULL;\n        fast = fast->next;\n    }\n    while (fast != NULL) {\n        fast = fast->next;\n        slow = slow->next;\n    }\n    return slow;\n}"
            }
        ]
    },
    {
        "algorithm": "Append the Last n Nodes of a Linked List to the Beginning",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to append the last n nodes of a linked list to the beginning\nvoid appendLastNToBeginning(struct Node** head_ref, int n) {\n    if (head_ref == NULL || n <= 0)\n        return;\n    struct Node temp = head_ref;\n    int length = 1;\n    while (temp->next != NULL) {\n        temp = temp->next;\n        length++;\n    }\n    if (n >= length)\n        return;\n    temp = head_ref;\n    for (int i = 1; i < length - n; i++)\n        temp = temp->next;\n    struct Node new_head = temp->next;\n    temp->next = NULL;\n    struct Node last = new_head;\n    while (last->next != NULL)\n        last = last->next;\n    last->next = *head_ref;\n    *head_ref = new_head;\n}"
            }
        ]
    },
    {
        "algorithm": "Check Whether Linked List is Palindrome or Not",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to check whether linked list is palindrome or not\nbool isPalindrome(struct Node* head) {\n    if (head == NULL || head->next == NULL)\n        return true;\n    struct Node* slow = head;\n    struct Node* fast = head;\n    while (fast->next != NULL && fast->next->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    struct Node* second_half = slow->next;\n    slow->next = NULL;\n    struct Node* prev = NULL;\n    struct Node* current = second_half;\n    struct Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    second_half = prev;\n    while (second_half != NULL) {\n        if (head->data != second_half->data)\n            return false;\n        head = head->next;\n        second_half = second_half->next;\n    }\n    return true;\n}"
            }
        ]
    },
    {
        "algorithm": "Fold a Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to fold a linked list\nvoid foldLinkedList(struct Node** head_ref) {\n    if (head_ref == NULL || (head_ref)->next == NULL)\n        return;\n    struct Node slow = head_ref;\n    struct Node fast = (head_ref)->next;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    struct Node second_half = slow->next;\n    slow->next = NULL;\n    struct Node prev = NULL;\n    struct Node* current = second_half;\n    struct Node* next = NULL;\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    second_half = prev;\n    struct Node* first_half = head_ref;\n    while (first_half != NULL && second_half != NULL) {\n        struct Node temp1 = first_half->next;\n        struct Node* temp2 = second_half->next;\n        first_half->next = second_half;\n        second_half->next = temp1;\n        first_half = temp1;\n        second_half = temp2;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Insert at a Given Position",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node at a given position in the linked list\nvoid insertAtPosition(struct Node** head_ref, int new_data, int position) {\n    if (position < 0)\n        return;\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    if (new_node == NULL)\n        return;\n    new_node->data = new_data;\n    if (position == 0) {\n        new_node->next = head_ref;\n        *head_ref = new_node;\n        return;\n    }\n    struct Node current = *head_ref;\n    for (int i = 0; i < position - 1 && current != NULL; i++)\n        current = current->next;\n    if (current == NULL)\n        return;\n    new_node->next = current->next;\n    current->next = new_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Delete at a Given Position",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node at a given position in the linked list\nvoid deleteAtPosition(struct Node** head_ref, int position) {\n    if (head_ref == NULL || position < 0)\n        return;\n    struct Node temp = head_ref;\n    if (position == 0) {\n        *head_ref = temp->next;\n        free(temp);\n        return;\n    }\n    for (int i = 0; temp != NULL && i < position - 1; i++)\n        temp = temp->next;\n    if (temp == NULL || temp->next == NULL)\n        return;\n    struct Node next_node = temp->next->next;\n    free(temp->next);\n    temp->next = next_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Doubly Linked List",
        "time_complexity": "N/A",
        "implementations": [
            {
                "language": "C",
                "code": "// Doubly linked list node\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};"
            }
        ]
    },
    {
        "algorithm": "Insertion in Doubly Linked List",
        "time_complexity": "O(1) for insertion at beginning/end, O(n) for insertion at nth node",
        "implementations": [
            {
                "language": "C",
                "code": "// Insertion functions can be found in subsequent JSON examples"
            }
        ]
    },
    {
        "algorithm": "Insertion at Beginning in Doubly Linked List",
        "time_complexity": "O(1)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node at the beginning of the doubly linked list\nvoid insertAtBeginning(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->prev = NULL;\n    new_node->next = *head_ref;\n    if (*head_ref != NULL)\n        (*head_ref)->prev = new_node;\n    *head_ref = new_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion at End in Doubly Linked List",
        "time_complexity": "O(1)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node at the end of the doubly linked list\nvoid insertAtEnd(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last = *head_ref;\n    new_node->data = new_data;\n    new_node->next = NULL;\n    if (*head_ref == NULL) {\n        new_node->prev = NULL;\n        *head_ref = new_node;\n        return;\n    }\n    while (last->next != NULL)\n        last = last->next;\n    last->next = new_node;\n    new_node->prev = last;\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion at Nth Node in Doubly Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node at the nth position of the doubly linked list\nvoid insertAtNthNode(struct Node** head_ref, int new_data, int position) {\n    if (position <= 0)\n        return;\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    if (head_ref == NULL) {\n        new_node->prev = NULL;\n        new_node->next = NULL;\n        *head_ref = new_node;\n        return;\n    }\n    struct Node current = *head_ref;\n    for (int i = 1; current != NULL && i < position; i++)\n        current = current->next;\n    if (current == NULL)\n        return;\n    new_node->next = current->next;\n    if (current->next != NULL)\n        current->next->prev = new_node;\n    current->next = new_node;\n    new_node->prev = current;\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion in Doubly Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Deletion functions can be found in subsequent JSON examples"
            }
        ]
    },
    {
        "algorithm": "Deletion from Beginning in Doubly Linked List",
        "time_complexity": "O(1)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node from the beginning of the doubly linked list\nvoid deleteFromBeginning(struct Node** head_ref) {\n    if (head_ref == NULL)\n        return;\n    struct Node temp = *head_ref;\n    *head_ref = (*head_ref)->next;\n    if (*head_ref != NULL)\n        (*head_ref)->prev = NULL;\n    free(temp);\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion from Nth in Doubly Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node from the nth position of the doubly linked list\nvoid deleteFromNthNode(struct Node** head_ref, int position) {\n    if (head_ref == NULL || position <= 0)\n        return;\n    struct Node current = *head_ref;\n    for (int i = 1; current != NULL && i < position; i++)\n        current = current->next;\n    if (current == NULL)\n        return;\n    if (current->next != NULL)\n        current->next->prev = current->prev;\n    if (current->prev != NULL)\n        current->prev->next = current->next;\n    if (current == *head_ref)\n        *head_ref = current->next;\n    free(current);\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion from End in Doubly Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node from the end of the doubly linked list\nvoid deleteFromEnd(struct Node** head_ref) {\n    if (head_ref == NULL)\n        return;\n    struct Node last = *head_ref;\n    while (last->next != NULL)\n        last = last->next;\n    if (last->prev != NULL)\n        last->prev->next = NULL;\n    else\n        *head_ref = NULL;\n    free(last);\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion in the Middle in a Doubly Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node in the middle of the doubly linked list\nvoid insertInMiddle(struct Node** head_ref, int new_data) {\n    if (head_ref == NULL)\n        return;\n    struct Node slow = head_ref;\n    struct Node fast = (head_ref)->next;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    struct Node new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->prev = slow;\n    new_node->next = slow->next;\n    if (slow->next != NULL)\n        slow->next->prev = new_node;\n    slow->next = new_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion in the Middle in a Doubly Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node from the middle of the doubly linked list\nvoid deleteFromMiddle(struct Node** head_ref) {\n    if (head_ref == NULL || (*head_ref)->next == NULL)\n        return;\n    struct Node slow = head_ref;\n    struct Node fast = (head_ref)->next->next;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    struct Node temp = slow->next;\n    slow->next = temp->next;\n    if (temp->next != NULL)\n        temp->next->prev = slow;\n    free(temp);\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion at the Beginning in Circular Linked List",
        "time_complexity": "O(1)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node at the beginning of the circular linked list\nvoid insertAtBeginning(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last = *head_ref;\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    if (*head_ref != NULL) {\n        while (last->next != *head_ref)\n            last = last->next;\n        last->next = new_node;\n    } else\n        new_node->next = new_node;\n    *head_ref = new_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion at the End in Circular Linked List",
        "time_complexity": "O(1)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node at the end of the circular linked list\nvoid insertAtEnd(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* last = *head_ref;\n    new_node->data = new_data;\n    new_node->next = *head_ref;\n    if (*head_ref == NULL) {\n        *head_ref = new_node;\n        return;\n    }\n    while (last->next != *head_ref)\n        last = last->next;\n    last->next = new_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion at Nth Position in Circular Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node at the nth position of the circular linked list\nvoid insertAtNthPosition(struct Node** head_ref, int new_data, int position) {\n    if (position <= 0)\n        return;\n    if (position == 1) {\n        insertAtBeginning(head_ref, new_data);\n        return;\n    }\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    struct Node* current = *head_ref;\n    for (int i = 1; i < position - 1 && current != NULL; i++)\n        current = current->next;\n    if (current == NULL)\n        return;\n    new_node->next = current->next;\n    current->next = new_node;\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion from Beginning in Circular Linked List",
        "time_complexity": "O(1)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node from the beginning of the circular linked list\nvoid deleteFromBeginning(struct Node** head_ref) {\n    if (head_ref == NULL)\n        return;\n    if ((*head_ref)->next == *head_ref) {\n        free(*head_ref);\n        *head_ref = NULL;\n    } else {\n        struct Node temp = *head_ref;\n        while (temp->next != *head_ref)\n            temp = temp->next;\n        temp->next = (*head_ref)->next;\n        free(*head_ref);\n        *head_ref = temp->next;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion from Nth Position in Circular Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node from the nth position of the circular linked list\nvoid deleteFromNthPosition(struct Node** head_ref, int position) {\n    if (head_ref == NULL || position <= 0)\n        return;\n    if (position == 1) {\n        deleteFromBeginning(head_ref);\n        return;\n    }\n    struct Node current = head_ref;\n    struct Node prev = NULL;\n    for (int i = 1; i < position && current->next != *head_ref; i++) {\n        prev = current;\n        current = current->next;\n    }\n    if (current == *head_ref)\n        return;\n    prev->next = current->next;\n    free(current);\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion from End in Circular Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node from the end of the circular linked list\nvoid deleteFromEnd(struct Node** head_ref) {\n    if (head_ref == NULL)\n        return;\n    if ((head_ref)->next == *head_ref) {\n        free(*head_ref);\n        *head_ref = NULL;\n    } else {\n        struct Node prev = NULL;\n        struct Node temp = *head_ref;\n        while (temp->next != *head_ref) {\n            prev = temp;\n            temp = temp->next;\n        }\n        prev->next = (*head_ref)->next;\n        free(*head_ref);\n        *head_ref = prev->next;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Split a Circular Linked List in Two Halves",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to split a circular linked list into two halves\nvoid splitCircularLinkedList(struct Node* head, struct Node** head1, struct Node** head2) {\n    if (head == NULL || head->next == head) {\n        head1 = head;\n        head2 = NULL;\n        return;\n    }\n    struct Node slow = head;\n    struct Node fast = head->next;\n    while (fast != head && fast->next != head) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    head1 = head;\n    *head2 = slow->next;\n    slow->next = *head1;\n    struct Node temp = *head2;\n    while (temp->next != head)\n        temp = temp->next;\n    temp->next = *head2;\n}"
            }
        ]
    },
    {
        "algorithm": "Count Nodes in Circular Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to count nodes in a circular linked list\nint countNodes(struct Node* head) {\n    if (head == NULL)\n        return 0;\n    int count = 0;\n    struct Node* current = head;\n    do {\n        count++;\n        current = current->next;\n    } while (current != head);\n    return count;\n}"
            }
        ]
    },
    {
        "algorithm": "Sorted Insert in Circular Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node in sorted order into a circular linked list\nvoid sortedInsert(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    struct Node* current = *head_ref;\n    if (current == NULL) {\n        new_node->next = new_node;\n        *head_ref = new_node;\n        return;\n    }\n    else if (current->data >= new_data) {\n        while (current->next != *head_ref)\n            current = current->next;\n        current->next = new_node;\n        new_node->next = *head_ref;\n        *head_ref = new_node;\n        return;\n    }\n    else {\n        while (current->next != *head_ref && current->next->data < new_data)\n            current = current->next;\n        new_node->next = current->next;\n        current->next = new_node;\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion in the Middle in Circular Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to insert a node in the middle of the circular linked list\nvoid insertInMiddle(struct Node** head_ref, int new_data) {\n    if (head_ref == NULL) {\n        head_ref = newNode;\n        newNode->next = *head_ref;\n        return;\n    }\n    struct Node slow = head_ref;\n    struct Node fast = (head_ref)->next;\n    while (fast != *head_ref && fast->next != *head_ref) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    struct Node newNode = (struct Node)malloc(sizeof(struct Node));\n    newNode->data = new_data;\n    newNode->next = slow->next;\n    slow->next = newNode;\n}"
            }
        ]
    },
    {
        "algorithm": "Deletion in the Middle in Circular Linked List",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to delete a node from the middle of the circular linked list\nvoid deleteFromMiddle(struct Node** head_ref) {\n    if (head_ref == NULL || (*head_ref)->next == *head_ref)\n        return;\n    struct Node slow = head_ref;\n    struct Node fast = (head_ref)->next->next;\n    while (fast != *head_ref && fast->next != *head_ref) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    struct Node temp = slow->next;\n    slow->next = temp->next;\n    free(temp);\n}"
            }
        ]
    },
    {
        "algorithm": "Representation of a Stack as an Array",
        "time_complexity": "O(1) for push and pop operations",
        "implementations": [
            {
                "language": "C",
                "code": "// Stack implementation using array\n#define MAX_SIZE 100\nstruct Stack {\n    int top;\n    int array[MAX_SIZE];\n};\n\n// Function to create a stack\nstruct Stack* createStack() {\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    stack->top = -1;\n    return stack;\n}\n\n// Function to check if the stack is empty\nint isEmpty(struct Stack* stack) {\n    return stack->top == -1;\n}\n\n// Function to push an element into the stack\nvoid push(struct Stack* stack, int item) {\n    if (stack->top == MAX_SIZE - 1)\n        return;\n    stack->array[++stack->top] = item;\n}\n\n// Function to pop an element from the stack\nint pop(struct Stack* stack) {\n    if (isEmpty(stack))\n        return INT_MIN;\n    return stack->array[stack->top--];\n}"
            }
        ]
    },
    {
        "algorithm": "Representation of a Stack as a Linked List",
        "time_complexity": "O(1) for push and pop operations",
        "implementations": [
            {
                "language": "C",
                "code": "// Stack implementation using linked list\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Stack {\n    struct Node* top;\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// Function to create a stack\nstruct Stack* createStack() {\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    stack->top = NULL;\n    return stack;\n}\n\n// Function to check if the stack is empty\nint isEmpty(struct Stack* stack) {\n    return stack->top == NULL;\n}\n\n// Function to push an element into the stack\nvoid push(struct Stack* stack, int data) {\n    struct Node* newNode = createNode(data);\n    newNode->next = stack->top;\n    stack->top = newNode;\n}\n\n// Function to pop an element from the stack\nint pop(struct Stack* stack) {\n    if (isEmpty(stack))\n        return INT_MIN;\n    struct Node* temp = stack->top;\n    int data = temp->data;\n    stack->top = temp->next;\n    free(temp);\n    return data;\n}"
            }
        ]
    },
    {
        "algorithm": "Infix to Prefix Conversion in Stack",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to push an element onto the stack\nvoid push(char* stack, int* top, char element) {\n    stack[++(top)] = element;\n}\n\n// Function to pop an element from the stack\nchar pop(char stack, int* top) {\n    if (top == -1)\n        return '\\0';\n    return stack[(top)--];\n}\n\n// Function to reverse a string\nvoid reverseString(char str) {\n    int i = 0, j = strlen(str) - 1;\n    while (i < j) {\n        char temp = str[i];\n        str[i] = str[j];\n        str[j] = temp;\n        i++;\n        j--;\n    }\n}\n\n// Function to convert infix expression to prefix expression\nvoid infixToPrefix(char infix, char* prefix) {\n    int len = strlen(infix);\n    reverseString(infix);\n    char postfix[MAX_SIZE];\n    infixToPostfix(infix, postfix);\n    reverseString(postfix);\n    strcpy(prefix, postfix);\n}"
            }
        ]
    },
    {
        "algorithm": "Postfix to Prefix Conversion in Stack",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to push an element onto the stack\nvoid push(char* stack, int* top, char element) {\n    stack[++(top)] = element;\n}\n\n// Function to pop an element from the stack\nchar pop(char stack, int* top) {\n    if (top == -1)\n        return '\\0';\n    return stack[(top)--];\n}\n\n// Function to convert postfix expression to prefix expression\nvoid postfixToPrefix(char postfix, char prefix) {\n    // Implementation goes here\n    char stack[MAX_SIZE];\n    int top = -1;\n    int i = 0;\n    while (postfix[i] != '\\0') {\n        if (isalnum(postfix[i])) {\n            push(stack, &top, postfix[i]);\n        } else {\n            char operand1 = pop(stack, &top);\n            char operand2 = pop(stack, &top);\n            prefix[i] = postfix[i];\n            prefix[i+1] = operand2;\n            prefix[i+2] = operand1;\n            i += 2;\n        }\n        i++;\n    }\n    prefix[i] = '\\0';\n}"
            }
        ]
    },
    {
        "algorithm": "Postfix to Infix Conversion in Stack",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "// Function to push an element onto the stack\nvoid push(char* stack, int* top, char element) {\n    stack[++(top)] = element;\n}\n\n// Function to pop an element from the stack\nchar pop(char stack, int* top) {\n    if (top == -1)\n        return '\\0';\n    return stack[(top)--];\n}\n\n// Function to convert postfix expression to infix expression\nvoid postfixToInfix(char postfix, char infix) {\n    // Implementation goes here\n    char stack[MAX_SIZE];\n    int top = -1;\n    int i = 0;\n    while (postfix[i] != '\\0') {\n        if (isalnum(postfix[i])) {\n            push(stack, &top, postfix[i]);\n        } else {\n            char operand1 = pop(stack, &top);\n            char operand2 = pop(stack, &top);\n            infix[i] = '(';\n            infix[i+1] = operand2;\n            infix[i+2] = postfix[i];\n            infix[i+3] = operand1;\n            infix[i+4] = ')';\n            i += 4;\n        }\n        i++;\n    }\n    infix[i] = '\\0';\n}"
            }
        ]
    },
    {
        "algorithm": "Insertion in Queues Program (Enqueuing)",
        "time_complexity": "O(1)",
        "implementations": [
            {
                "language": "C",
                "code": "void enqueue(int queue[], int *rear, int item) {\n    if (*rear == MAX - 1)\n        printf(\"Queue Overflow\\n\");\n    else {\n        if (*rear == -1)\n            *rear = 0;\n        queue[++(*rear)] = item;\n    }\n}"
            }
        ],
        "sub_functions": []
    },
    {
        "algorithm": "Deletion (Removal) in Queues Program(Dequeuing)",
        "time_complexity": "O(1)",
        "implementations": [
            {
                "language": "C",
                "code": "int dequeue(int queue[], int *front, int *rear) {\n    int item;\n    if (*front == -1 || *front > *rear) {\n        printf(\"Queue Underflow\\n\");\n        return -1;\n    } else {\n        item = queue[*front];\n        (*front)++;\n        return item;\n    }\n}"
            }
        ],
        "sub_functions": []
    },
    {
        "algorithm": "Reverse a Queue",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "void reverseQueue(int queue[], int *front, int *rear) {\n    int stack[MAX], top = -1;\n    while (*front != *rear) {\n        stack[++top] = dequeue(queue, front, rear);\n    }\n    while (top != -1) {\n        enqueue(queue, rear, stack[top--]);\n    }\n}"
            }
        ],
        "sub_functions": [
            {
                "name": "push",
                "language": "C",
                "code": "void push(int stack[], int *top, int item) {\n    if (*top == MAX - 1)\n        printf(\"Stack Overflow\\n\");\n    else\n        stack[++(*top)] = item;\n}"
            },
            {
                "name": "pop",
                "language": "C",
                "code": "int pop(int stack[], int *top) {\n    if (*top == -1) {\n        printf(\"Stack Underflow\\n\");\n        return -1;\n    } else {\n        return stack[(*top)--];\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Linear Search",
        "time_complexity": "O(n)",
        "implementations": [
            {
                "language": "C",
                "code": "int linearSearch(int arr[], int n, int x) {\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == x)\n            return i;\n    }\n    return -1; // Element not found\n}"
            }
        ]
    },
    {
        "algorithm": "Binary Search",
        "time_complexity": "O(log n)",
        "implementations": [
            {
                "language": "C",
                "code": "int binarySearch(int arr[], int l, int r, int x) {\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] < x)\n            l = mid + 1;\n        else\n            r = mid - 1;\n    }\n    return -1; // Element not found\n}"
            }
        ]
    },
    {
        "algorithm": "Inorder Tree Traversal",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "void inorderTraversal(struct TreeNode* root) {\n    if (root != NULL) {\n        inorderTraversal(root->left);\n        printf(\"%d \", root->val);\n        inorderTraversal(root->right);\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Preorder Tree Traversal",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "void preorderTraversal(struct TreeNode* root) {\n    if (root != NULL) {\n        printf(\"%d \", root->val);\n        preorderTraversal(root->left);\n        preorderTraversal(root->right);\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Postorder Tree Traversal",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "void postorderTraversal(struct TreeNode* root) {\n    if (root != NULL) {\n        postorderTraversal(root->left);\n        postorderTraversal(root->right);\n        printf(\"%d \", root->val);\n    }\n}"
            }
        ]
    },
    {
        "algorithm": "Inorder Tree Traversal without Recursion",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "void inorderTraversalWithoutRecursion(struct TreeNode* root) {\n    struct TreeNode* current = root;\n    struct Stack* stack = createStack(MAX_SIZE);\n\n    while (current != NULL || !isEmpty(stack)) {\n        while (current != NULL) {\n            push(stack, current);\n            current = current->left;\n        }\n        current = pop(stack);\n        printf(\"%d \", current->val);\n        current = current->right;\n    }\n    free(stack);\n}"
            }
        ]
    },
    {
        "algorithm": "Preorder Tree Traversal without Recursion",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "void preorderTraversalWithoutRecursion(struct TreeNode* root) {\n    if (root == NULL) return;\n    struct Stack* stack = createStack(MAX_SIZE);\n    push(stack, root);\n\n    while (!isEmpty(stack)) {\n        struct TreeNode* current = pop(stack);\n        printf(\"%d \", current->val);\n\n        if (current->right != NULL) push(stack, current->right);\n        if (current->left != NULL) push(stack, current->left);\n    }\n    free(stack);\n}"
            }
        ]
    },
    {
        "algorithm": "Postorder Tree Traversal without Recursion",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "void postorderTraversalWithoutRecursion(struct TreeNode* root) {\n    if (root == NULL) return;\n    struct Stack* stack1 = createStack(MAX_SIZE);\n    struct Stack* stack2 = createStack(MAX_SIZE);\n    push(stack1, root);\n\n    while (!isEmpty(stack1)) {\n        struct TreeNode* current = pop(stack1);\n        push(stack2, current);\n\n        if (current->left != NULL) push(stack1, current->left);\n        if (current->right != NULL) push(stack1, current->right);\n    }\n\n    while (!isEmpty(stack2)) {\n        printf(\"%d \", pop(stack2)->val);\n    }\n    free(stack1);\n    free(stack2);\n}"
            }
        ]
    },
    {
        "algorithm": "Breadth-First Search (BFS)",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "void BFS(struct TreeNode* root) {\n    if (root == NULL) return;\n    struct Queue* queue = createQueue(MAX_SIZE);\n    enqueue(queue, root);\n\n    while (!isEmpty(queue)) {\n        struct TreeNode* current = dequeue(queue);\n        printf(\"%d \", current->val);\n\n        if (current->left != NULL) enqueue(queue, current->left);\n        if (current->right != NULL) enqueue(queue, current->right);\n    }\n    free(queue);\n}"
            }
        ]
    },
    {
        "algorithm": "Depth First Search (DFS)",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "void DFS(struct TreeNode* root) {\n    if (root == NULL) return;\n    printf(\"%d \", root->val);\n\n    if (root->left != NULL) DFS(root->left);\n    if (root->right != NULL) DFS(root->right);\n}"
            }
        ]
    },
    {
        "algorithm": "Size of Binary Tree",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "int sizeOfBinaryTree(struct TreeNode* root) {\n    if (root == NULL) return 0;\n    return 1 + sizeOfBinaryTree(root->left) + sizeOfBinaryTree(root->right);\n}"
            }
        ]
    },
    {
        "algorithm": "Height of Binary Tree",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "int heightOfBinaryTree(struct TreeNode* root) {\n    if (root == NULL) return -1; // Assuming height of an empty tree is -1\n    int leftHeight = heightOfBinaryTree(root->left);\n    int rightHeight = heightOfBinaryTree(root->right);\n    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);\n}"
            }
        ]
    },
    {
        "algorithm": "Maximum Value in Binary Tree",
        "time_complexity": "O(n)",
        "language": "C",
        "implementations": [
            {
                "code": "int maxValueInBinaryTree(struct TreeNode* root) {\n    if (root == NULL) return INT_MIN; // Assuming the tree contains integers\n    int maxLeft = maxValueInBinaryTree(root->left);\n    int maxRight = maxValueInBinaryTree(root->right);\n    return (root->val > maxLeft && root->val > maxRight) ? root->val : (maxLeft > maxRight) ? maxLeft : maxRight;\n}"
            }
        ]
    }
]